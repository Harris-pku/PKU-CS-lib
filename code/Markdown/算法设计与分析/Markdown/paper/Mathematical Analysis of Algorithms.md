## Mathematical Analysis of Algorithms

对两个问题进行算法效率分析：$(a)$ 不使用额外空间的排序算法 $(b)$ 在有序线性表中查找第 $k$ 大的值。

#### 1. Introduction

算法分析处于数学与计算机交叉的重要领域，目标是量化算法优劣。主要讨论以下两类问题：$A$ 型：分析一个特定算法。分析其时空复杂度。$B$ 型：分析一类算法。在解决某一问题的所有相关算法中找出最优算法或给出时间复杂度下界。

$B$ 型分析比 $A$ 型出现的晚，而且因为可以一次解决一大类问题因此似乎要比 $A$ 类更高级，但所谓的“最优性”会随着要求的微小改变而产生巨大变化。例如计算 $x^{31}$ 时至少需要 $9$ 次乘法，但如果允许使用除法的话只需要 $6$ 次即可。

两个原因使得 $B$ 类并不能取代 $A$ 类算法。首先，进行 $B$ 类分析所需的简单模型往往不切合实际。其次，即便采用了简单模型，分析起来也是非常困难的。而 $A$ 类分析的实用性更强，而且对于技术性调整并不特别敏感。

#### 2. In Situ Permutation

第一个例子，考虑将数组从 $(x_1, x_2, \cdots, x_n)$ 变换到 $(x_{p(1)}, x_{p(2)}, \cdots, x_{p(n)})$，其中 $p$ 是 $\{1, 2, \cdots, n\}$ 的全排列。只能利用 $O(1)$ 的额外存储空间。

定义圈头 $j$：满足 $j < p(j)$, $j < p(p(j))$, $j < p(p(p(j)))$, $\rm etc$. 则每一个圈都有圈头。

1. $\rm for$  $j$  $=$  $1$  $\rm to$  $n$ 																			$1$ 
2. ​    // 任何一个位置如果圈头小于 $j$，则已经完成移动
3. ​    $k = p(j)$;                                                                                     $n$ 
4. ​    $\rm while$  $k > j$  $\rm do$                                                                      $n+a$ 
5. ​            $k = p(k)$;                                                                             $a$ 
6. ​    $\rm if$  $k == j$  $\rm do$                                                                              $n$ 
7. ​            // $j$ 是圈头 
8. ​            $y = x[k]$; $l = p(k)$                                                               $b$ 
9. ​            $\rm while$  $l != j$                                                                      $b+c$ 
10. ​                    $x[k] = x[l]$; $k = l$; $l = p(k)$;                                      $c$ 
11. ​            $x[k] = y$;                                                                               $b$ 

根据基尔霍夫定律设出 $n$, $a$, $b$, $c$ 计算时间复杂度。$b$ 是圈数，$a$ 是从该元素起到第一个不比此元素大的元素的距离之和。注意到 $a$ 取最优时 $b$ 取最坏，$b$ 取最优时 $a$ 取最坏。考虑平均情况时可认为 $n!$ 种 $p$ 函数出现的概率是相同的。

将排列通过圈的性质重新进行表述。$(8 \ 2 \ 7 \ 1 \ 6 \ 9 \ 3 \ 4 \ 5) \to (1 \ 8 \ 4)(5 \ 6 \ 9)(2)(7 \ 3)$ 当满足下面两个条件时表述形式唯一 $(1)$ 每个圈从圈头写起 $(2)$ 按每个圈的圈头降序排列。由于每个圈尾结尾的数都比下一个圈头的数大因此可省略括号。

因此我们可以把 $(p(1), p(2), \cdots, p(n))$ 对应到 $(q(1), q(2), \cdots, q(n))$. $b$ 的含义为 $q$ 中满足 $q(j) = \min\{ q(i) \ | \ 1 \leq i \leq j \}$ 的个数（即圈数），可表示为第一类斯特林数 $\begin{bmatrix} n \\ k \end{bmatrix}$。$b$ 的均值为 $H_n$，方差为 $H_n - H_n^{(2)}$. 分别为 $1$ 阶和 $2$ 阶调和级数。
$$
H_n = 1 + \cfrac{1}{2} + \cdots + \cfrac{1}{n} \qquad H_n^{(2)} = 1 + \cfrac{1}{4} + \cdots + \cfrac{1}{n^2}
$$
为表示 $a$，定义 $y_{ij}$,  $1 \leq i < j \leq n$.	 $y_{ij} = \begin{cases}
1, & {\rm if} \ q(i) < q(k) \ \ {\rm for} \ i < k \leq j \\
0, & {\rm otherwise}
\end{cases}$ 

得到 $a = \displaystyle \sum _ {1 \leq i < j \leq n} y_{ij}$. 计算得出 $a$ 的均值与方差。

$\overline{a} = (n+1) H_n - 2n$.				 $\sigma^2 = 2n^2 - (n+1)^2 H_n^{(2)} - (n+1)H_n + 4n$. 

算法平均复杂度为 $O(n\log n)$. 最坏时间复杂度为 $O(n^2)$. 

#### 3. Selecting the $t$th Largest

采用类似快排的思想选择第 $k$ 大数。

#### 4. Summary

1. 在进行算法分析时，数学被应用于计算机问题。
2. 算法分析依赖于离散数学的技巧。
3. 算法分析有通用解法，一项成果可应用于多项分析。











